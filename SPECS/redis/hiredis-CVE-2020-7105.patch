From 3e2ddf9cf72e7d5e19b096fbc03c411fdb9e92dc Mon Sep 17 00:00:00 2001
From: Chris Lamb <chris@chris-lamb.co.uk>
Date: Wed, 22 Jan 2020 21:56:54 +0000
Subject: [PATCH] Abort if malloc() was unsuccessful. (Closes: #747, #751)

NOTE: took changes from above commit and recreated a patch inorder to apply it successfully on this version(0.13.3) of hiredis
---
diff --git a/deps/hiredis/adapters/ae.h b/deps/hiredis/adapters/ae.h
index 5c551c2..4c2659f 100644
--- a/deps/hiredis/adapters/ae.h
+++ b/deps/hiredis/adapters/ae.h
@@ -109,6 +109,8 @@ static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
 
     /* Create container for context and r/w events */
     e = (redisAeEvents*)malloc(sizeof(*e));
+    if (e == NULL)
+	REDIS_OOM_HANDLER;
     e->context = ac;
     e->loop = loop;
     e->fd = c->fd;
diff --git a/deps/hiredis/adapters/ivykis.h b/deps/hiredis/adapters/ivykis.h
index 6a12a86..1f806e9 100644
--- a/deps/hiredis/adapters/ivykis.h
+++ b/deps/hiredis/adapters/ivykis.h
@@ -56,6 +56,8 @@ static int redisIvykisAttach(redisAsyncContext *ac) {
 
     /* Create container for context and r/w events */
     e = (redisIvykisEvents*)malloc(sizeof(*e));
+    if (e == NULL)
+	REDIS_OOM_HANDLER;
     e->context = ac;
 
     /* Register functions to start/stop listening for events */
diff --git a/deps/hiredis/adapters/libevent.h b/deps/hiredis/adapters/libevent.h
index 273d8b2..317c113 100644
--- a/deps/hiredis/adapters/libevent.h
+++ b/deps/hiredis/adapters/libevent.h
@@ -88,6 +88,8 @@ static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {
 
     /* Create container for context and r/w events */
     e = (redisLibeventEvents*)malloc(sizeof(*e));
+    if (e == NULL)
+	REDIS_OOM_HANDLER;
     e->context = ac;
 
     /* Register functions to start/stop listening for events */
diff --git a/deps/hiredis/async.c b/deps/hiredis/async.c
index d955203..0a39b8e 100644
--- a/deps/hiredis/async.c
+++ b/deps/hiredis/async.c
@@ -69,6 +69,8 @@ static unsigned int callbackHash(const void *key) {
 static void *callbackValDup(void *privdata, const void *src) {
     ((void) privdata);
     redisCallback *dup = malloc(sizeof(*dup));
+    if (dup == NULL)
+	REDIS_OOM_HANDLER;
     memcpy(dup,src,sizeof(*dup));
     return dup;
 }
diff --git a/deps/hiredis/dict.c b/deps/hiredis/dict.c
index e17a625..3c1a416 100644
--- a/deps/hiredis/dict.c
+++ b/deps/hiredis/dict.c
@@ -33,6 +33,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "hiredis.h"
 #include "fmacros.h"
 #include <stdlib.h>
 #include <assert.h>
@@ -72,6 +73,8 @@ static void _dictReset(dict *ht) {
 /* Create a new hash table */
 static dict *dictCreate(dictType *type, void *privDataPtr) {
     dict *ht = malloc(sizeof(*ht));
+    if (ht == NULL)
+	REDIS_OOM_HANDLER;
     _dictInit(ht,type,privDataPtr);
     return ht;
 }
@@ -98,7 +101,8 @@ static int dictExpand(dict *ht, unsigned long size) {
     n.size = realsize;
     n.sizemask = realsize-1;
     n.table = calloc(realsize,sizeof(dictEntry*));
-
+    if (n.table == NULL)
+	REDIS_OOM_HANDLER;
     /* Copy all the elements from the old to the new table:
      * note that if the old hash table is empty ht->size is zero,
      * so dictExpand just creates an hash table. */
@@ -143,6 +147,8 @@ static int dictAdd(dict *ht, void *key, void *val) {
 
     /* Allocates the memory and stores key */
     entry = malloc(sizeof(*entry));
+    if (entry == NULL)
+	REDIS_OOM_HANDLER;
     entry->next = ht->table[index];
     ht->table[index] = entry;
 
@@ -258,6 +264,8 @@ static dictEntry *dictFind(dict *ht, const void *key) {
 static dictIterator *dictGetIterator(dict *ht) {
     dictIterator *iter = malloc(sizeof(*iter));
 
+    if(iter == NULL)
+	REDIS_OOM_HANDLER;
     iter->ht = ht;
     iter->index = -1;
     iter->entry = NULL;
diff --git a/deps/hiredis/hiredis.h b/deps/hiredis/hiredis.h
index 423d5e5..1dfeeea 100644
--- a/deps/hiredis/hiredis.h
+++ b/deps/hiredis/hiredis.h
@@ -80,6 +80,10 @@
  * SO_REUSEADDR is being used. */
 #define REDIS_CONNECT_RETRIES  10
 
+#ifndef REDIS_OOM_HANDLER
+#define REDIS_OOM_HANDLER abort();
+#endif
+
 /* strerror_r has two completely different prototypes and behaviors
  * depending on system issues, so we need to operate on the error buffer
  * differently depending on which strerror_r we're using. */
