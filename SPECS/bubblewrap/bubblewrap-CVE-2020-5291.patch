From 5404a15d34301a5a0dd5930203e03c76b80ebf21 Mon Sep 17 00:00:00 2001
From: Alexander Larsson <alexl@redhat.com>
Date: Thu, 26 Mar 2020 15:36:44 +0100
Subject: [PATCH] Don't rely on geteuid() to know when to switch back from
 setuid root
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

As pointed out by Stephen RÃ¶ttger <sroettger@google.com>, in
drop_privs() we only drop root in the setuid case if geteuid() is
0. Typically geteuid() == 0 means we were setuid root and have not yet
switched away from it.

However, it is possible to make the geteuid call fail by passing a
--userns2 namespace which doesn't have 0 mapped (i.e. where geteuid()
will return the owerflow uid instead).

If you do this, the pid 1 process in the sandbox will continue running
as host uid 0, while dropping the dumpable flag, and at this point the
user can ptrace attach the process and have root permissions.

We fix this by not relying on the geteuid() call to know when we need
to drop root uid, but rather keep track of whether we already switched
from it.
---
 bubblewrap.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/bubblewrap.c b/bubblewrap.c
index 0e1560b..8b53df9 100644
--- a/bubblewrap.c
+++ b/bubblewrap.c
@@ -600,13 +600,14 @@ switch_to_user_with_privs (void)
 }
 
 static void
-drop_privs (void)
+drop_privs (bool already_changed_uid)
 {
   if (!is_privileged)
     return;
 
   /* Drop root uid */
-  if (setuid (opt_sandbox_uid) < 0)
+  if (is_privileged && !already_changed_uid &&
+            setuid (opt_sandbox_uid) < 0)
     die_with_error ("unable to drop root uid");
 
   drop_all_caps ();
@@ -1905,7 +1906,7 @@ main (int    argc,
       /* Initial launched process, wait for exec:ed command to exit */
 
       /* We don't need any privileges in the launcher, drop them immediately. */
-      drop_privs ();
+      drop_privs (FALSE);
 
       /* Optionally bind our lifecycle to that of the parent */
       handle_die_with_parent ();
@@ -2036,7 +2037,7 @@ main (int    argc,
       if (child == 0)
         {
           /* Unprivileged setup process */
-          drop_privs ();
+          drop_privs (TRUE);
           close (privsep_sockets[0]);
           setup_newroot (opt_unshare_pid, privsep_sockets[1]);
           exit (0);
@@ -2102,7 +2103,7 @@ main (int    argc,
     die_with_error ("chdir /");
 
   /* All privileged ops are done now, so drop it */
-  drop_privs ();
+  drop_privs (TRUE);
 
   if (opt_block_fd != -1)
     {
