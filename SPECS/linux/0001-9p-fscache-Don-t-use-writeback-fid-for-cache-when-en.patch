From 85530e833f3541ea2ba64ebbc0bc1406d8f9bd39 Mon Sep 17 00:00:00 2001
From: Amod Mishra <mamod@vmware.com>
Date: Mon, 7 Sep 2020 12:25:37 -0700
Subject: [PATCH] [9p-fscache] Don't use writeback fid for cache when enabled
 for VDFS

Writeback fid is used for data caching. It is utilized to write dirty pages back to the server.Writeback fid is associated with an inode. An inode may still be cached even in case file is closed,the writeback_fid associated to the inode in cache is still opened, and the file descriptor on host of the writeback_fid is also kept opened.This can cuase too many files opened at the host.VDFS does not use caching for data and to avoid above issue, usage of writeback fid for VDFS has been prohibited.
---
 fs/9p/vfs_file.c       | 4 ++++
 fs/9p/vfs_inode.c      | 1 +
 fs/9p/vfs_inode_dotl.c | 1 +
 3 files changed, 6 insertions(+)

diff --git a/fs/9p/vfs_file.c b/fs/9p/vfs_file.c
index c685dd0..0fe51ae 100644
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@ -91,6 +91,7 @@ int v9fs_file_open(struct inode *inode, struct file *file)
 	file->private_data = fid;
 	mutex_lock(&v9inode->v_mutex);
 	if ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&
+            !v9ses->metaonly &&
 	    !v9inode->writeback_fid &&
 	    ((file->f_flags & O_ACCMODE) != O_RDONLY)) {
 		/*
@@ -556,11 +557,14 @@ v9fs_mmap_file_mmap(struct file *filp, struct vm_area_struct *vma)
 	struct inode *inode;
 	struct v9fs_inode *v9inode;
 	struct p9_fid *fid;
+	struct v9fs_session_info *v9ses;
 
 	inode = file_inode(filp);
 	v9inode = V9FS_I(inode);
+	v9ses = v9fs_inode2v9ses(inode);
 	mutex_lock(&v9inode->v_mutex);
 	if (!v9inode->writeback_fid &&
+	    !v9ses->metaonly &&
 	    (vma->vm_flags & VM_SHARED) &&
 	    (vma->vm_flags & VM_WRITE)) {
 		/*
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index 3076eca..3feccad 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -898,6 +898,7 @@ v9fs_vfs_atomic_open(struct inode *dir, struct dentry *dentry,
 	v9inode = V9FS_I(d_inode(dentry));
 	mutex_lock(&v9inode->v_mutex);
 	if ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&
+	    !v9ses->metaonly &&
 	    !v9inode->writeback_fid &&
 	    ((flags & O_ACCMODE) != O_RDONLY)) {
 		/*
diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c
index a655397..965e708 100644
--- a/fs/9p/vfs_inode_dotl.c
+++ b/fs/9p/vfs_inode_dotl.c
@@ -332,6 +332,7 @@ v9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,
 	v9inode = V9FS_I(inode);
 	mutex_lock(&v9inode->v_mutex);
 	if ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&
+	    !v9ses->metaonly &&
 	    !v9inode->writeback_fid &&
 	    ((flags & O_ACCMODE) != O_RDONLY)) {
 		/*
-- 
2.6.2

