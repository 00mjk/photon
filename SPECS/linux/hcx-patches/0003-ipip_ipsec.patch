From e35abea6fc639bb771a276740de20d4b9eef9149 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 24 Jul 2020 14:20:55 +0530
Subject: [PATCH 3/7] ipip_ipsec.patch

This patch fixes the encapsulation logic which is caused by the appliance.
Without this, the encap code will try to copy values like TTL from
the inner packet header.  But those are encrypted, so invalid to use.
---
 net/ipv4/ipip.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c
index da2e923..414bce4 100644
--- a/net/ipv4/ipip.c
+++ b/net/ipv4/ipip.c
@@ -117,6 +117,13 @@
 #include <net/netns/generic.h>
 #include <net/dst_metadata.h>
 
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+extern int ipip_tunnel_skip_encap_decap __read_mostly;
+#else
+#define ipip_tunnel_skip_encap_decap 0
+#endif
+
 static bool log_ecn_error = true;
 module_param(log_ecn_error, bool, 0644);
 MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
@@ -297,6 +304,24 @@ static netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb,
 		goto tx_error;
 	}
 
+	/* If there is already encapsulation present, ipip tries to
+	* use the inner-most header for things like copying ttl and
+	* tos.  That is okay, unless ipsec encrypted the inner
+	* header.  In that case, ipip tries to use encrypted values
+	* instead of the real ones.  Prevent that by treating ipsec
+	* as non encapsulated.
+	*
+	* It's not clear this is 100% correct solution.  It feels
+	* more like ipsec should prevent this, but it fixes our use
+	* case.
+	*/
+	if ( ipip_tunnel_skip_encap_decap && skb->encapsulation) {
+		struct iphdr *iph = ip_hdr(skb);
+		if (iph->protocol == IPPROTO_ESP) {
+			skb->encapsulation = 0;
+		}
+	}
+
 	if (tiph->protocol != ipproto && tiph->protocol != 0)
 		goto tx_error;
 
-- 
2.7.4

