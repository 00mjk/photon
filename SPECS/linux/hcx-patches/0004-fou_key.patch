From aa4622d60324f7a6f08e05b600c68c0613ca80c0 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 24 Jul 2020 14:21:36 +0530
Subject: [PATCH 4/7] fou_key.patch

The standard fou code only lets you have a single tunnel between two IPs.
You can specify port or range(s) that are allowed, but all will come to a
single fou netdev. This patch allows for there to be multiple fou tunnels
between two ddresses, by adding the key.
---
 include/linux/skbuff.h |  1 +
 net/ipv4/fou.c         |  5 ++++
 net/ipv4/ipip.c        | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 72 insertions(+)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 25407c2..1f9c1b9 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -845,6 +845,7 @@ struct sk_buff {
 	__u16			network_header;
 	__u16			mac_header;
 
+	__be32			fou_key;
 	/* private: */
 	__u32			headers_end[0];
 	/* public: */
diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c
index 854ff1e..e26bbb5 100644
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@ -51,6 +51,11 @@ static inline struct fou *fou_from_sock(struct sock *sk)
 
 static int fou_recv_pull(struct sk_buff *skb, struct fou *fou, size_t len)
 {
+	struct udphdr *udph = udp_hdr(skb);
+
+	/* Save udp ports for use as key later.
+	 */
+	skb->fou_key = (((udph->source) << 16) | udph->dest);
 	/* Remove 'len' bytes from the packet (UDP header and
 	 * FOU header if present).
 	 */
diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c
index 414bce4..9696d7d 100644
--- a/net/ipv4/ipip.c
+++ b/net/ipv4/ipip.c
@@ -120,8 +120,11 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 extern int ipip_tunnel_skip_encap_decap __read_mostly;
+static struct ctl_table_header *ipip_sysctl_header;
+int fou_key_multi_port __read_mostly = 0;
 #else
 #define ipip_tunnel_skip_encap_decap 0
+#define fou_key_multi_port 0
 #endif
 
 static bool log_ecn_error = true;
@@ -133,6 +136,30 @@ static unsigned int ipip_net_id __read_mostly;
 static int ipip_tunnel_init(struct net_device *dev);
 static struct rtnl_link_ops ipip_link_ops __read_mostly;
 
+#ifdef CONFIG_SYSCTL
+static struct ctl_table ipip_sysctl_table[] = {
+	{
+		.procname	= "fou_key_multi_port",
+		.data		= &fou_key_multi_port,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{}
+};
+
+static int ipip_sysctl_init(void)
+{
+	ipip_sysctl_header = register_net_sysctl(&init_net, "net/ipv4", ipip_sysctl_table);
+	if (ipip_sysctl_header == NULL) {
+		printk(KERN_ERR "ipip: can't register to sysctl");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+#endif
+
 static int ipip_err(struct sk_buff *skb, u32 info)
 {
 	/* All the routers (except for Linux) return only
@@ -233,6 +260,10 @@ static int ipip_tunnel_rcv(struct sk_buff *skb, u8 ipproto)
 	iph = ip_hdr(skb);
 	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
 			iph->saddr, iph->daddr, 0);
+	if (fou_key_multi_port && !tunnel) {
+		tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_KEY,
+		                          iph->saddr, iph->daddr, skb->fou_key);
+	}
 	if (tunnel) {
 		const struct tnl_ptk_info *tpi;
 
@@ -522,6 +553,28 @@ static bool ipip_netlink_encap_parms(struct nlattr *data[],
 	return ret;
 }
 
+static void ipip_fou_fixup_key(struct ip_tunnel_parm *p,
+			       struct ip_tunnel_encap *ipencap)
+{
+	/* If no key is provided, but encap src/dst ports are,
+	 * set key based on src/dst ports.  Allows for multiple
+	 * fou tunnels using different port pairs.  Requires
+	 * storing ports/key in skb header between fou and ipip
+	 * layer.
+	 */
+	if ((ipencap->type == TUNNEL_ENCAP_FOU) &&
+	    (ipencap->sport != 0) && (ipencap->dport != 0) &&
+	    (p->i_key == 0) && (p->o_key == 0)) {
+		/* For arriving packets, key is (sport << 16 | dport)
+		 * so need to reverse things here for i_key.
+		 * o_key is set to same, but it's never used for fou
+		 */
+		p->i_key = (ipencap->dport << 16) | ipencap->sport;
+		p->o_key = p->i_key;
+		p->i_flags |= TUNNEL_KEY;
+	}
+}
+
 static int ipip_newlink(struct net *src_net, struct net_device *dev,
 			struct nlattr *tb[], struct nlattr *data[],
 			struct netlink_ext_ack *extack)
@@ -539,6 +592,9 @@ static int ipip_newlink(struct net *src_net, struct net_device *dev,
 	}
 
 	ipip_netlink_parms(data, &p, &t->collect_md, &fwmark);
+	if (fou_key_multi_port) {
+		ipip_fou_fixup_key(&p, &ipencap);
+	}
 	return ip_tunnel_newlink(dev, tb, &p, fwmark);
 }
 
@@ -560,6 +616,9 @@ static int ipip_changelink(struct net_device *dev, struct nlattr *tb[],
 	}
 
 	ipip_netlink_parms(data, &p, &collect_md, &fwmark);
+	if (fou_key_multi_port) {
+		ipip_fou_fixup_key(&p, &ipencap);
+	}
 	if (collect_md)
 		return -EINVAL;
 
@@ -723,6 +782,9 @@ static int __init ipip_init(void)
 	err = rtnl_link_register(&ipip_link_ops);
 	if (err < 0)
 		goto rtnl_link_failed;
+#ifdef CONFIG_SYSCTL
+	ipip_sysctl_init();
+#endif
 
 out:
 	return err;
@@ -749,6 +811,10 @@ static void __exit ipip_fini(void)
 		pr_info("%s: can't deregister tunnel\n", __func__);
 #endif
 	unregister_pernet_device(&ipip_net_ops);
+
+#ifdef CONFIG_SYSCTL
+	unregister_net_sysctl_table(ipip_sysctl_header);
+#endif
 }
 
 module_init(ipip_init);
-- 
2.7.4

