From: "kiyin(尹亮)" <kiyin@tencent.com>
Subject: [PATCH] perf/core: Fix a leak in perf_event_parse_addr_filter()

The "filename" allocation is not always freed.  This was has been shown
through runtime testing.  It looks like there are three possible ways
that this could happen.  It could be allocated twice on subsequent
iterations through the loop, or leaked on the success path or on the
failure path.

Reported-by: "kiyin(尹亮)" <kiyin@tencent.com>
Fixes: 375637bc5249 ("perf/core: Introduce address range filtering")
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: Keerthana K <keerthanak@vmware.com>
---

 kernel/events/core.c | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/kernel/events/core.c b/kernel/events/core.c
index 9358471..534f282 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -8259,6 +8259,7 @@ perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
 			if (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {
 				int fpos = filter->range ? 2 : 1;
 
+				kfree(filename);
 				filename = match_strdup(&args[fpos]);
 				if (!filename) {
 					ret = -ENOMEM;
@@ -8289,12 +8290,10 @@ perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
 				/* look up the path and grab its inode */
 				ret = kern_path(filename, LOOKUP_FOLLOW, &path);
 				if (ret)
-					goto fail_free_name;
+					goto fail;
 
 				filter->inode = igrab(d_inode(path.dentry));
 				path_put(&path);
-				kfree(filename);
-				filename = NULL;
 
 				ret = -EINVAL;
 				if (!filter->inode ||
@@ -10160,13 +10158,13 @@ perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
 	if (state != IF_STATE_ACTION)
 		goto fail;

+	kfree(filename);
 	kfree(orig);

 	return 0;

-fail_free_name:
-	kfree(filename);
 fail:
+	kfree(filename);
 	free_filters_list(filters);
 	kfree(orig);

--
2.28.0
