From ddc650e9b3dc916eab417ce9f79e67337b05035c Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@suse.de>
Date: Wed, 19 Feb 2020 17:21:46 +0100
Subject: [PATCH 1/1] Fix use-after-free in glob when expanding ~user (bug
 25414)

The value of `end_name' points into the value of `dirname', thus don't
deallocate the latter before the last use of the former.

Signed-off-by: Keerthana K <keerthanak@vmware.com>
---
 posix/glob.c | 25 +++++++++++++------------
 1 file changed, 13 insertions(+), 12 deletions(-)


diff --git a/posix/glob.c b/posix/glob.c
index 6db26c8..f23ac6e 100644
--- a/posix/glob.c
+++ b/posix/glob.c
@@ -946,28 +946,30 @@ glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 	      {
 		size_t home_len = strlen (p->pw_dir);
 		size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
+		char *newp;
+		bool use_alloca = glob_use_alloca (alloca_used,
+						   home_len + rest_len + 1);
 
-		if (__glibc_unlikely (malloc_dirname))
-		  free (dirname);
-		malloc_dirname = 0;
-
-		if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
-		  dirname = alloca_account (home_len + rest_len + 1,
-					    alloca_used);
+		if (use_alloca)
+		  newp = alloca_account (home_len + rest_len + 1, alloca_used);
 		else
 		  {
-		    dirname = malloc (home_len + rest_len + 1);
-		    if (dirname == NULL)
+		      newp = malloc (home_len + rest_len + 1);
+		      if (newp == NULL)
 		      {
 			free (malloc_pwtmpbuf);
 			retval = GLOB_NOSPACE;
 			goto out;
 		      }
-		    malloc_dirname = 1;
 		  }
-		*((char *) mempcpy (mempcpy (dirname, p->pw_dir, home_len),
+		*((char *) mempcpy (mempcpy (newp, p->pw_dir, home_len),
 				    end_name, rest_len)) = '\0';
 
+		if (__glibc_unlikely (malloc_dirname))
+		  free (dirname);
+		dirname = newp;
+		malloc_dirname = !use_alloca;
+
 		dirlen = home_len + rest_len;
 		dirname_modified = 1;
 
