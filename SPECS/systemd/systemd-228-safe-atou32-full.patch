diff -rupN systemd-228/src/basic/parse-util.c systemd-228-safe-atou32-full/src/basic/parse-util.c
--- systemd-228/src/basic/parse-util.c	2015-11-18 07:59:06.000000000 +0000
+++ systemd-228-safe-atou32-full/src/basic/parse-util.c	2020-06-06 12:11:14.486402580 +0000
@@ -490,3 +490,38 @@ int safe_atod(const char *s, double *ret
         *ret_d = (double) d;
         return 0;
 }
+
+int safe_atou_full(const char *s, unsigned base, unsigned *ret_u) {
+        char *x = NULL;
+        unsigned long l;
+
+        assert(s);
+        assert(base <= 16);
+
+        /* strtoul() is happy to parse negative values, and silently
+         * converts them to unsigned values without generating an
+         * error. We want a clean error, hence let's look for the "-"
+         * prefix on our own, and generate an error. But let's do so
+         * only after strtoul() validated that the string is clean
+         * otherwise, so that we return EINVAL preferably over
+         * ERANGE. */
+
+        s += strspn(s, WHITESPACE);
+
+        errno = 0;
+        l = strtoul(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if (s[0] == '-')
+                return -ERANGE;
+        if ((unsigned long) (unsigned) l != l)
+                return -ERANGE;
+
+        if (ret_u)
+                *ret_u = (unsigned) l;
+
+        return 0;
+}
+
diff -rupN systemd-228/src/basic/parse-util.h systemd-228-safe-atou32-full/src/basic/parse-util.h
--- systemd-228/src/basic/parse-util.h	2015-11-18 07:59:06.000000000 +0000
+++ systemd-228-safe-atou32-full/src/basic/parse-util.h	2020-06-06 12:13:31.686799330 +0000
@@ -49,11 +49,16 @@ int safe_atou8(const char *s, uint8_t *r
 int safe_atou16(const char *s, uint16_t *ret);
 int safe_atoi16(const char *s, int16_t *ret);
 
-static inline int safe_atou32(const char *s, uint32_t *ret_u) {
+int safe_atou_full(const char *s, unsigned base, unsigned *ret_u);
+
+static inline int safe_atou32_full(const char *s, unsigned base, uint32_t *ret_u) {
         assert_cc(sizeof(uint32_t) == sizeof(unsigned));
-        return safe_atou(s, (unsigned*) ret_u);
+        return safe_atou_full(s, base, (unsigned*) ret_u);
 }
 
+static inline int safe_atou32(const char *s, uint32_t *ret_u) {
+        return safe_atou32_full(s, 0, (unsigned*) ret_u);
+}
 static inline int safe_atoi32(const char *s, int32_t *ret_i) {
         assert_cc(sizeof(int32_t) == sizeof(int));
         return safe_atoi(s, (int*) ret_i);
