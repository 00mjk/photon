diff --color -rupN systemd-239/src/network/networkd-dhcp4.c systemd-239-use-routes/src/network/networkd-dhcp4.c
--- systemd-239/src/network/networkd-dhcp4.c	2020-08-24 04:33:39.893335751 +0000
+++ systemd-239-use-routes/src/network/networkd-dhcp4.c	2020-08-24 05:04:51.083463427 +0000
@@ -67,9 +67,6 @@ static int link_set_dhcp_routes(Link *li
         if (!link->network) /* link went down while we configured the IP addresses? */
                 return 0;
 
-        if (!link->network->dhcp_use_routes)
-                return 0;
-
         /* When the interface is part of an VRF use the VRFs routing table, unless
          * there is a another table specified. */
         table = link->network->dhcp_route_table;
@@ -92,91 +89,95 @@ static int link_set_dhcp_routes(Link *li
                         static_route = true;
         }
 
-        for (i = 0; i < n; i++) {
-                _cleanup_(route_freep) Route *route = NULL;
-
-                /* if the DHCP server returns both a Classless Static Routes option and a Static Routes option,
-                   the DHCP client MUST ignore the Static Routes option. */
-                if (classless_route && static_routes[i]->option == SD_DHCP_OPTION_STATIC_ROUTE)
-                        continue;
-
-                r = route_new(&route);
-                if (r < 0)
-                        return log_link_error_errno(link, r, "Could not allocate route: %m");
-
-                route->family = AF_INET;
-                route->protocol = RTPROT_DHCP;
-                assert_se(sd_dhcp_route_get_gateway(static_routes[i], &route->gw.in) >= 0);
-                assert_se(sd_dhcp_route_get_destination(static_routes[i], &route->dst.in) >= 0);
-                assert_se(sd_dhcp_route_get_destination_prefix_length(static_routes[i], &route->dst_prefixlen) >= 0);
-                route->priority = link->network->dhcp_route_metric;
-                route->table = table;
-                route->scope = route_scope_from_address(route, &address);
-
-                r = route_configure(route, link, dhcp4_route_handler);
-                if (r < 0)
-                        return log_link_warning_errno(link, r, "Could not set host route: %m");
+        if (link->network->dhcp_use_routes) {
+                for (i = 0; i < n; i++) {
+                        _cleanup_(route_freep) Route *route = NULL;
+
+                        /* if the DHCP server returns both a Classless Static Routes option and a Static Routes option,
+                           the DHCP client MUST ignore the Static Routes option. */
+                        if (classless_route && static_routes[i]->option == SD_DHCP_OPTION_STATIC_ROUTE)
+                                continue;
+
+                        r = route_new(&route);
+                        if (r < 0)
+                                return log_link_error_errno(link, r, "Could not allocate route: %m");
+
+                        route->family = AF_INET;
+                        route->protocol = RTPROT_DHCP;
+                        assert_se(sd_dhcp_route_get_gateway(static_routes[i], &route->gw.in) >= 0);
+                        assert_se(sd_dhcp_route_get_destination(static_routes[i], &route->dst.in) >= 0);
+                        assert_se(sd_dhcp_route_get_destination_prefix_length(static_routes[i], &route->dst_prefixlen) >= 0);
+                        route->priority = link->network->dhcp_route_metric;
+                        route->table = table;
+                        route->scope = route_scope_from_address(route, &address);
+
+                        r = route_configure(route, link, dhcp4_route_handler);
+                        if (r < 0)
+                                return log_link_warning_errno(link, r, "Could not set host route: %m");
 
-                link->dhcp4_messages++;
+                        link->dhcp4_messages++;
+                }
         }
 
-        r = sd_dhcp_lease_get_router(link->dhcp_lease, &gateway);
-        if (r == -ENODATA)
-                log_link_info_errno(link, r, "DHCP: No routes received from DHCP server: %m");
-        else if (r < 0)
-                log_link_warning_errno(link, r, "DHCP error: could not get gateway: %m");
-
-        /* According to RFC 3442: If the DHCP server returns both a Classless Static Routes option and
-           a Router option, the DHCP client MUST ignore the Router option. */
-        if (classless_route && static_route)
-                log_link_warning(link, "Classless static routes received from DHCP server: ignoring static-route option and router option");
-
-        if (r >= 0 && !classless_route) {
-                _cleanup_(route_freep) Route *route = NULL;
-                _cleanup_(route_freep) Route *route_gw = NULL;
-
-                r = route_new(&route);
-                if (r < 0)
-                        return log_link_error_errno(link, r, "Could not allocate route: %m");
-
-                route->protocol = RTPROT_DHCP;
-
-                r = route_new(&route_gw);
-                if (r < 0)
-                        return log_link_error_errno(link, r,  "Could not allocate route: %m");
-
-                /* The dhcp netmask may mask out the gateway. Add an explicit
-                 * route for the gw host so that we can route no matter the
-                 * netmask or existing kernel route tables. */
-                route_gw->family = AF_INET;
-                route_gw->dst.in = gateway;
-                route_gw->dst_prefixlen = 32;
-                route_gw->prefsrc.in = address;
-                route_gw->scope = RT_SCOPE_LINK;
-                route_gw->protocol = RTPROT_DHCP;
-                route_gw->priority = link->network->dhcp_route_metric;
-                route_gw->table = table;
-
-                r = route_configure(route_gw, link, dhcp4_route_handler);
-                if (r < 0)
-                        return log_link_warning_errno(link, r, "Could not set host route: %m");
-
-                link->dhcp4_messages++;
-
-                route->family = AF_INET;
-                route->gw.in = gateway;
-                route->prefsrc.in = address;
-                route->priority = link->network->dhcp_route_metric;
-                route->table = table;
-
-                r = route_configure(route, link, dhcp4_route_handler);
-                if (r < 0) {
-                        log_link_warning_errno(link, r, "Could not set routes: %m");
-                        link_enter_failed(link);
-                        return r;
-                }
+        if (link->network->dhcp_use_gateway) {
+                r = sd_dhcp_lease_get_router(link->dhcp_lease, &gateway);
+                if (r == -ENODATA)
+                        log_link_info_errno(link, r, "DHCP: No routes received from DHCP server: %m");
+                else if (r < 0)
+                        log_link_warning_errno(link, r, "DHCP error: could not get gateway: %m");
+
+                /* According to RFC 3442: If the DHCP server returns both a Classless Static Routes option and
+                   a Router option, the DHCP client MUST ignore the Router option. */
+                if (classless_route && static_route)
+                        log_link_warning(link, "Classless static routes received from DHCP server: ignoring static-route option and router option");
+
+                if (r >= 0 && !classless_route) {
+                        _cleanup_(route_freep) Route *route = NULL;
+                        _cleanup_(route_freep) Route *route_gw = NULL;
+
+                        r = route_new(&route);
+                        if (r < 0)
+                                return log_link_error_errno(link, r, "Could not allocate route: %m");
+
+                        route->protocol = RTPROT_DHCP;
+
+                        r = route_new(&route_gw);
+                        if (r < 0)
+                                return log_link_error_errno(link, r,  "Could not allocate route: %m");
+
+                        /* The dhcp netmask may mask out the gateway. Add an explicit
+                         * route for the gw host so that we can route no matter the
+                         * netmask or existing kernel route tables. */
+                        route_gw->family = AF_INET;
+                        route_gw->dst.in = gateway;
+                        route_gw->dst_prefixlen = 32;
+                        route_gw->prefsrc.in = address;
+                        route_gw->scope = RT_SCOPE_LINK;
+                        route_gw->protocol = RTPROT_DHCP;
+                        route_gw->priority = link->network->dhcp_route_metric;
+                        route_gw->table = table;
+
+                        r = route_configure(route_gw, link, dhcp4_route_handler);
+                        if (r < 0)
+                                return log_link_warning_errno(link, r, "Could not set host route: %m");
+
+                        link->dhcp4_messages++;
+
+                        route->family = AF_INET;
+                        route->gw.in = gateway;
+                        route->prefsrc.in = address;
+                        route->priority = link->network->dhcp_route_metric;
+                        route->table = table;
+
+                        r = route_configure(route, link, dhcp4_route_handler);
+                        if (r < 0) {
+                                log_link_warning_errno(link, r, "Could not set routes: %m");
+                                link_enter_failed(link);
+                                return r;
+                        }
 
-                link->dhcp4_messages++;
+                        link->dhcp4_messages++;
+                }
         }
 
         return 0;
diff --color -rupN systemd-239/src/network/networkd-link.c systemd-239-use-routes/src/network/networkd-link.c
--- systemd-239/src/network/networkd-link.c	2020-08-24 04:33:40.029336232 +0000
+++ systemd-239-use-routes/src/network/networkd-link.c	2020-08-24 04:49:48.284524911 +0000
@@ -3957,6 +3957,8 @@ static const char* const link_state_tabl
          [LINK_STATE_CONFIGURING] = "configuring",
          [LINK_STATE_CONFIGURED] = "configured",
          [LINK_STATE_UNMANAGED] = "unmanaged",
+         [LINK_STATE_FAILED] = "failed",
+         [LINK_STATE_LINGER] = "linger",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(link_state, LinkState);
diff --color -rupN systemd-239/src/network/networkd-network.c systemd-239-use-routes/src/network/networkd-network.c
--- systemd-239/src/network/networkd-network.c	2020-08-24 04:33:39.905335794 +0000
+++ systemd-239-use-routes/src/network/networkd-network.c	2020-08-24 05:01:31.714782118 +0000
@@ -194,6 +194,7 @@ static int network_load_one(Manager *man
         network->ipv6_accept_ra_use_onlink_prefix = true;
         network->dhcp_use_hostname = true;
         network->dhcp_use_routes = true;
+        network->dhcp_use_gateway = true;
         /* NOTE: this var might be overwriten by network_apply_anonymize_if_set */
         network->dhcp_send_hostname = true;
         /* To enable/disable RFC7844 Anonymity Profiles */
diff --color -rupN systemd-239/src/network/networkd-network-gperf.gperf systemd-239-use-routes/src/network/networkd-network-gperf.gperf
--- systemd-239/src/network/networkd-network-gperf.gperf	2020-08-24 04:33:39.921335850 +0000
+++ systemd-239-use-routes/src/network/networkd-network-gperf.gperf	2020-08-24 05:02:27.362974431 +0000
@@ -123,6 +123,7 @@ DHCP.UseMTU,
 DHCP.UseHostname,                       config_parse_bool,                              0,                             offsetof(Network, dhcp_use_hostname)
 DHCP.UseDomains,                        config_parse_dhcp_use_domains,                  0,                             offsetof(Network, dhcp_use_domains)
 DHCP.UseRoutes,                         config_parse_bool,                              0,                             offsetof(Network, dhcp_use_routes)
+DHCP.UseGateway,                        config_parse_bool,                              0,                             offsetof(Network, dhcp_use_gateway)
 DHCP.Anonymize,                         config_parse_bool,                              0,                             offsetof(Network, dhcp_anonymize)
 DHCP.SendHostname,                      config_parse_bool,                              0,                             offsetof(Network, dhcp_send_hostname)
 DHCP.Hostname,                          config_parse_hostname,                          0,                             offsetof(Network, dhcp_hostname)
diff --color -rupN systemd-239/src/network/networkd-network.h systemd-239-use-routes/src/network/networkd-network.h
--- systemd-239/src/network/networkd-network.h	2020-08-24 04:33:39.921335850 +0000
+++ systemd-239-use-routes/src/network/networkd-network.h	2020-08-24 04:58:15.690118869 +0000
@@ -134,6 +134,7 @@ struct Network {
         bool dhcp_use_ntp;
         bool dhcp_use_mtu;
         bool dhcp_use_routes;
+        bool dhcp_use_gateway;
         bool dhcp_use_timezone;
         bool rapid_commit;
         bool dhcp_use_hostname;
