commit 83790d5c58c77d20c8e35f3e29c9a1519afd6a77
Author: Dirkjan Ochtman <d.ochtman@activevideo.com>
Date:   Tue Dec 24 15:31:29 2013 +0100

    soup-session: add soup_session_connect{_async,_finish} functions (bug 721343)
    
    New function added to asynchronously establish a connection. This uses
    soup-session mechanics to do proxy/SSL stuff, but returns an established
    connection to the caller as a GIOStream.

diff --git a/libsoup/soup-message-queue.h b/libsoup/soup-message-queue.h
index f86a129..edc43cd 100644
--- a/libsoup/soup-message-queue.h
+++ b/libsoup/soup-message-queue.h
@@ -48,6 +48,7 @@
 	guint new_api           : 1;
 	guint io_started        : 1;
 	guint async             : 1;
+        guint force_tunnel      : 1;
 	guint conn_is_dedicated : 1;
 	guint priority          : 3;
 	guint resend_count      : 25;
commit 07f9ecb7fc65800b6fb9ccb16f06afebde327903
commit 3766b1ca00f792a36c6b397888bc8ba9e45a44f9
Author: Dirkjan Ochtman <d.ochtman@activevideo.com>
Date:   Wed Apr 23 16:20:26 2014 +0200

    soup-session: build GError object for CONNECT failures (bug 727434)

Author: Dirkjan Ochtman <dirkjan@ochtman.nl>
Date:   Tue Jun 17 10:46:42 2014 +0200

    soup-session: don't try to disconnect NULL connection

diff --git a/libsoup/soup-session.c b/libsoup/soup-session.c
index 9831172..af4c2d2 100644
--- a/libsoup/soup-session.c
+++ b/libsoup/soup-session.c
@@ -9,6 +9,7 @@
 #include <config.h>
 #endif
 
+#include <stdlib.h>
 #include <glib/gi18n-lib.h>
 
 #include "soup-session.h"
@@ -165,6 +166,8 @@ static void async_run_queue (SoupSession *session);
 
 static void async_send_request_running (SoupSession *session, SoupMessageQueueItem *item);
 
+static void extract_connection (SoupSession *session, SoupMessageQueueItem *item);
+
 #define SOUP_SESSION_MAX_CONNS_DEFAULT 10
 #define SOUP_SESSION_MAX_CONNS_PER_HOST_DEFAULT 2
 
@@ -1658,16 +1661,24 @@ tunnel_complete (SoupMessageQueueItem *tunnel_item,
 
 	if (item->msg->status_code)
 		item->state = SOUP_MESSAGE_FINISHING;
+
 	soup_message_set_https_status (item->msg, item->conn);
 
 	item->error = error;
 	if (!status)
 		status = status_from_connect_error (item, error);
+
+	if (!error && !SOUP_STATUS_IS_SUCCESSFUL (status)) {
+		error = g_error_new (SOUP_HTTP_ERROR, status, soup_status_get_phrase (status));
+		item->error = error;
+	}
+
 	if (!SOUP_STATUS_IS_SUCCESSFUL (status)) {
-		soup_connection_disconnect (item->conn);
+                if (item->conn) soup_connection_disconnect (item->conn);
 		soup_session_set_item_connection (session, item, NULL);
-		if (!item->new_api || item->msg->status_code == 0)
+		if (!item->new_api || item->msg->status_code == 0) {
 			soup_session_set_item_status (session, item, status, error);
+                }
 	}
 
 	item->state = SOUP_MESSAGE_READY;
@@ -1696,6 +1707,7 @@ tunnel_message_completed (SoupMessage *msg, SoupMessageIOCompletion completion,
 	SoupMessageQueueItem *tunnel_item = user_data;
 	SoupMessageQueueItem *item = tunnel_item->related;
 	SoupSession *session = tunnel_item->session;
+        gboolean is_ssl;
 	guint status;
 
 	if (tunnel_item->state == SOUP_MESSAGE_RESTARTING) {
@@ -1719,6 +1731,12 @@ tunnel_message_completed (SoupMessage *msg, SoupMessageIOCompletion completion,
 		return;
 	}
 
+        g_object_get (G_OBJECT (item->conn), "ssl", &is_ssl, NULL);
+        if (!is_ssl) {
+                tunnel_complete (tunnel_item, status, NULL);
+                return;
+        }
+
 	if (tunnel_item->async) {
 		soup_connection_start_ssl_async (item->conn, item->cancellable,
 						 tunnel_handshake_complete,
@@ -1998,13 +2016,21 @@ soup_session_process_queue_item (SoupSession          *session,
 			break;
 
 		case SOUP_MESSAGE_CONNECTED:
-			if (soup_connection_is_tunnelled (item->conn))
-				tunnel_connect (item);
-			else
-				item->state = SOUP_MESSAGE_READY;
+                        if (soup_connection_is_via_proxy (item->conn)) {
+                                if (item->force_tunnel || soup_connection_is_tunnelled (item->conn)) {
+                                        tunnel_connect (item);
+                                        break;
+                                }
+                        }
+                        item->state = SOUP_MESSAGE_READY;
 			break;
 
 		case SOUP_MESSAGE_READY:
+                        if (item->force_tunnel) {
+                                item->state = SOUP_MESSAGE_FINISHING;
+                                break;
+                        }
+
 			if (item->msg->status_code) {
 				if (item->msg->status_code == SOUP_STATUS_TRY_AGAIN) {
 					soup_message_cleanup_response (item->msg);
@@ -2051,6 +2077,8 @@ soup_session_process_queue_item (SoupSession          *session,
 			}
 
 			soup_message_queue_item_ref (item);
+                        if (item->force_tunnel)
+                                extract_connection (session, item);
 			soup_session_unqueue_item (session, item);
 			if (item->async && item->callback)
 				item->callback (session, item->msg, item->callback_data);
@@ -4707,6 +4735,94 @@ soup_request_error_quark (void)
 	return error;
 }
 
+void extract_connection (SoupSession *session, SoupMessageQueueItem *item) {
+
+       SoupSocket *sock;
+       SoupURI *uri;
+       SoupSessionHost *host;
+       GIOStream *iostream;
+       GError *error;
+       SoupConnection *soup_conn;
+       SoupSessionPrivate *priv;
+
+       soup_conn = item->conn;
+       item->conn = NULL;
+       error = (!soup_conn && item->error) ? g_error_copy(item->error) : NULL;
+       soup_session_set_item_connection (session, item, NULL);
+
+       if (!soup_conn) {
+               g_task_return_error (item->task, error);
+               return;
+       }
+
+       priv = SOUP_SESSION_GET_PRIVATE (session);
+       uri = soup_message_get_uri (item->msg);
+       host = get_host_for_uri (session, uri);
+
+       g_mutex_lock (&priv->conn_lock);
+       g_hash_table_remove (priv->conns, soup_conn);
+       drop_connection (session, host, soup_conn);
+       g_mutex_unlock (&priv->conn_lock);
+
+       sock = soup_connection_get_socket(soup_conn);
+       g_object_unref (soup_conn);
+
+       iostream = soup_socket_get_connection(sock);
+       g_object_ref (iostream);
+       g_object_set (G_OBJECT (sock), "close-on-dispose", FALSE, NULL);
+       g_object_unref (sock);
+
+       g_task_return_pointer (item->task, iostream, g_object_unref);
+}
+
+/**
+ * soup_session_connect_finish:
+ * @session: a #SoupSession
+ * @result: the #GAsyncResult from the connect operation
+ * @user_data: outparam for possible errors
+ *
+ * Since: 2.46
+ */
+GIOStream* soup_session_connect_finish (SoupSession *session,
+                          GAsyncResult *result,
+                          GError **error) {
+       g_return_val_if_fail (g_task_is_valid (result, session), NULL);
+       return g_task_propagate_pointer ( G_TASK (result), error);
+}
+
+/**
+ * soup_session_connect_async:
+ * @session: a #SoupSession
+ * @destination: a #SoupURI representing the URI/host to connect to
+ * @callback: a callback to call when the connection is established
+ * @user_data: data for @callback
+ *
+ * Sets up a #SoupConnection to the @destination according to the
+ * usual #SoupSession process (i.e. complete with TLS and proxy
+ * setup). The resulting #GIOStream is then passed to the callback
+ * after the associated #SoupConnection and #SoupSocket are freed.
+ *
+ * Since: 2.46
+ */
+void soup_session_connect_async (SoupSession *session,
+                          SoupURI *destination,
+                          GAsyncReadyCallback callback,
+                          gpointer user_data) {
+       SoupMessage *msg;
+       SoupMessageQueueItem *item;
+
+       msg = soup_message_new_from_uri (SOUP_METHOD_HEAD, destination);
+       item = soup_session_append_queue_item (session, msg, TRUE, TRUE,
+                                              NULL, NULL);
+       soup_message_queue_item_ref (item);
+
+       item->new_api = TRUE;
+       item->force_tunnel = TRUE;
+       item->task = g_task_new (session, NULL, callback, user_data);
+       g_task_set_task_data (item->task, item, (GDestroyNotify) soup_message_queue_item_unref);
+       soup_session_kick_queue (session);
+}
+
 /**
  * soup_session_steal_connection:
  * @session: a #SoupSession
diff --git a/libsoup/soup-session.h b/libsoup/soup-session.h
index 67a59ea..933cca8 100644
--- a/libsoup/soup-session.h
+++ b/libsoup/soup-session.h
@@ -198,6 +198,15 @@ SOUP_AVAILABLE_IN_2_42
 GQuark soup_request_error_quark (void);
 #define SOUP_REQUEST_ERROR soup_request_error_quark ()
 
+void soup_session_connect_async (SoupSession *session,
+						SoupURI					*destination,
+						GAsyncReadyCallback		callback,
+						gpointer				user_data);
+
+GIOStream* soup_session_connect_finish (SoupSession *session,
+					    GAsyncResult		     *result,
+					    GError				    **error);
+
 typedef enum {
 	SOUP_REQUEST_ERROR_BAD_URI,
 	SOUP_REQUEST_ERROR_UNSUPPORTED_URI_SCHEME,

commit 31a878547a50aca3b3b34b1376e51bb546ca2650
Author: Dirkjan Ochtman <d.ochtman@activevideo.com>
Date:   Mon Jan 6 09:09:34 2014 +0100

    soup-socket: add flag close_on_dispose to SoupSocket

diff --git a/libsoup/soup-socket-private.h b/libsoup/soup-socket-private.h
index c0bb7a1..6aa90ca 100644
--- a/libsoup/soup-socket-private.h
+++ b/libsoup/soup-socket-private.h
@@ -13,6 +13,7 @@
 #define SOUP_SOCKET_GSOCKET           "gsocket"
 #define SOUP_SOCKET_IOSTREAM          "iostream"
 #define SOUP_SOCKET_IPV6_ONLY         "ipv6-only"
+#define SOUP_SOCKET_CLOSE_ON_DISPOSE "close-on-dispose"
 
 gboolean   soup_socket_connect_sync_internal   (SoupSocket           *sock,
 						GCancellable         *cancellable,
diff --git a/libsoup/soup-socket.c b/libsoup/soup-socket.c
index 594e38b..592cd60 100644
--- a/libsoup/soup-socket.c
+++ b/libsoup/soup-socket.c
@@ -68,6 +68,7 @@ enum {
 	PROP_TLS_CERTIFICATE,
 	PROP_TLS_ERRORS,
 	PROP_SOCKET_PROPERTIES,
+        PROP_CLOSE_ON_DISPOSE,
 
 	LAST_PROP
 };
@@ -89,6 +90,7 @@ typedef struct {
 	guint ssl_strict:1;
 	guint ssl_fallback:1;
 	guint clean_dispose:1;
+        guint close_on_dispose:1;
 	guint use_thread_context:1;
 	gpointer ssl_creds;
 
@@ -116,6 +118,7 @@ soup_socket_init (SoupSocket *sock)
 	SoupSocketPrivate *priv = SOUP_SOCKET_GET_PRIVATE (sock);
 
 	priv->non_blocking = TRUE;
+        priv->close_on_dispose = TRUE;
 	priv->fd = -1;
 	g_mutex_init (&priv->addrlock);
 	g_mutex_init (&priv->iolock);
@@ -211,7 +214,7 @@ soup_socket_finalize (GObject *object)
 			g_warning ("Disposing socket %p during connect", object);
 		g_object_unref (priv->connect_cancel);
 	}
-	if (priv->conn) {
+        if (priv->gsock && priv->close_on_dispose) {
 		if (priv->clean_dispose)
 			g_warning ("Disposing socket %p while still connected", object);
 		disconnect_internal (SOUP_SOCKET (object), TRUE);
@@ -361,6 +364,9 @@ soup_socket_set_property (GObject *object, guint prop_id,
 			priv->clean_dispose = TRUE;
 		}
 		break;
+        case PROP_CLOSE_ON_DISPOSE:
+                priv->close_on_dispose = g_value_get_boolean (value);
+                break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -422,6 +428,9 @@ soup_socket_get_property (GObject *object, guint prop_id,
 	case PROP_TLS_ERRORS:
 		g_value_set_flags (value, priv->tls_errors);
 		break;
+        case PROP_CLOSE_ON_DISPOSE:
+                g_value_set_boolean (value, priv->close_on_dispose);
+                break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -795,6 +804,14 @@ soup_socket_class_init (SoupSocketClass *socket_class)
 				     "Socket properties",
 				     SOUP_TYPE_SOCKET_PROPERTIES,
 				     G_PARAM_WRITABLE));
+
+        g_object_class_install_property (
+                 object_class, PROP_CLOSE_ON_DISPOSE,
+                 g_param_spec_boolean (SOUP_SOCKET_CLOSE_ON_DISPOSE,
+                                       "Close socket on disposal",
+                                       "Whether the socket is closed on disposal",
+                                       TRUE,
+                                       G_PARAM_READWRITE));
 }
 
 static void
