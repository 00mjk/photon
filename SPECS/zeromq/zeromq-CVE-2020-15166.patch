commit 18665a8e6db6f2c81583c8b1a81c04353515f0cb
Author: Shreenidhi Shedi <sshedi@vmware.com>
Date:   Thu Sep 3 14:50:46 2020 +0530

    problem: zeromq connects peer before handshake is completed
    
    Solution: delay connecting the peer pipe until the handshake is completed
    (cherry picked from commit e7f0090b161ce6344f6bd35009816a925c070b09)
    
    For more info:
    https://github.com/zeromq/libzmq/commit/e7f0090b161ce6344f6bd35009816a925c070b09
    
    Signed-off-by: Shreenidhi Shedi <sshedi@vmware.com>

diff --git a/src/i_engine.hpp b/src/i_engine.hpp
index 0897606d..714a0820 100644
--- a/src/i_engine.hpp
+++ b/src/i_engine.hpp
@@ -41,6 +41,10 @@ namespace zmq
     {
         virtual ~i_engine () {}
 
+        //  Indicate if the engine has an handshake stage.
+        //  If engine has handshake stage, engine must call session.engine_ready when the handshake is complete.
+        virtual bool has_handshake_stage () = 0;
+
         //  Plug the engine to the session.
         virtual void plug (zmq::io_thread_t *io_thread_,
             class session_base_t *session_) = 0;
diff --git a/src/ipc_connecter.cpp b/src/ipc_connecter.cpp
index 48793e8c..5fba6331 100644
--- a/src/ipc_connecter.cpp
+++ b/src/ipc_connecter.cpp
@@ -122,8 +122,8 @@ void zmq::ipc_connecter_t::out_event ()
         return;
     }
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow)
-        stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Attach the engine to the corresponding session object.
diff --git a/src/ipc_listener.cpp b/src/ipc_listener.cpp
index 40e9ecba..06831c75 100644
--- a/src/ipc_listener.cpp
+++ b/src/ipc_listener.cpp
@@ -171,8 +171,8 @@ void zmq::ipc_listener_t::in_event ()
     }
 
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow)
-        stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Choose I/O thread to run connecter in. Given that we are already
diff --git a/src/norm_engine.hpp b/src/norm_engine.hpp
index d45e1946..536fef31 100644
--- a/src/norm_engine.hpp
+++ b/src/norm_engine.hpp
@@ -84,6 +84,8 @@ namespace zmq
                     bool InSync() const
                         {return in_sync;}
 
+                    bool has_handshake_stage () { return false; };
+
                     // These are used to feed data to decoder
                     // and its underlying "msg" buffer
                     char* AccessBuffer()
diff --git a/src/pgm_receiver.hpp b/src/pgm_receiver.hpp
index 7c854e78..5ed0aab5 100644
--- a/src/pgm_receiver.hpp
+++ b/src/pgm_receiver.hpp
@@ -58,6 +58,7 @@ namespace zmq
         int init (bool udp_encapsulation_, const char *network_);
 
         //  i_engine interface implementation.
+        bool has_handshake_stage () { return false; };
         void plug (zmq::io_thread_t *io_thread_,
             zmq::session_base_t *session_);
         void terminate ();
diff --git a/src/pgm_sender.hpp b/src/pgm_sender.hpp
index 973bac26..abff818d 100644
--- a/src/pgm_sender.hpp
+++ b/src/pgm_sender.hpp
@@ -57,6 +57,7 @@ namespace zmq
         int init (bool udp_encapsulation_, const char *network_);
 
         //  i_engine interface implementation.
+        bool has_handshake_stage () { return false; };
         void plug (zmq::io_thread_t *io_thread_,
             zmq::session_base_t *session_);
         void terminate ();
diff --git a/src/session_base.cpp b/src/session_base.cpp
index 84212361..e1ce2989 100644
--- a/src/session_base.cpp
+++ b/src/session_base.cpp
@@ -280,7 +280,8 @@ void zmq::session_base_t::read_activated (pipe_t *pipe_)
     }
 
     if (unlikely (engine == NULL)) {
-        pipe->check_read ();
+        if (pipe)
+            pipe->check_read ();
         return;
     }
 
@@ -384,6 +385,18 @@ void zmq::session_base_t::process_attach (i_engine *engine_)
 {
     zmq_assert (engine_ != NULL);
 
+    zmq_assert (!engine);
+    engine = engine_;
+
+    if (!engine_->has_handshake_stage ())
+        engine_ready ();
+
+    //  Plug in the engine.
+    engine->plug (io_thread, this);
+}
+
+void zmq::session_base_t::engine_ready ()
+{
     //  Create the pipe if it does not exist yet.
     if (!pipe && !is_terminating ()) {
         object_t *parents [2] = {this, socket};
@@ -412,11 +425,6 @@ void zmq::session_base_t::process_attach (i_engine *engine_)
         //  Ask socket to plug into the remote end of the pipe.
         send_bind (socket, pipes [1]);
     }
-
-    //  Plug in the engine.
-    zmq_assert (!engine);
-    engine = engine_;
-    engine->plug (io_thread, this);
 }
 
 void zmq::session_base_t::engine_error (
diff --git a/src/session_base.hpp b/src/session_base.hpp
index be92a67c..863464bd 100644
--- a/src/session_base.hpp
+++ b/src/session_base.hpp
@@ -67,6 +67,7 @@ namespace zmq
         virtual void reset ();
         void flush ();
         void engine_error (zmq::stream_engine_t::error_reason_t reason);
+        void engine_ready ();
 
         //  i_pipe_events interface implementation.
         void read_activated (zmq::pipe_t *pipe_);
diff --git a/src/socks_connecter.cpp b/src/socks_connecter.cpp
index ab14dcd5..1a948199 100644
--- a/src/socks_connecter.cpp
+++ b/src/socks_connecter.cpp
@@ -150,8 +150,8 @@ void zmq::socks_connecter_t::in_event ()
                 error ();
             else {
                 //  Create the engine object for this connection.
-                stream_engine_t *engine = new (std::nothrow)
-                    stream_engine_t (s, options, endpoint);
+                stream_engine_t *engine =
+                    new (std::nothrow) stream_engine_t (s, options, endpoint, !options.raw_socket);
                 alloc_assert (engine);
 
                 //  Attach the engine to the corresponding session object.
@@ -436,7 +436,7 @@ zmq::fd_t zmq::socks_connecter_t::check_proxy_connection ()
         options.tcp_keepalive_idle, options.tcp_keepalive_intvl);
     if (rc != 0)
         return -1;
-    
+
     return 0;
 }
 
diff --git a/src/stream_engine.cpp b/src/stream_engine.cpp
index f0f28871..21bc388d 100644
--- a/src/stream_engine.cpp
+++ b/src/stream_engine.cpp
@@ -62,8 +62,10 @@
 #include "likely.hpp"
 #include "wire.hpp"
 
-zmq::stream_engine_t::stream_engine_t (fd_t fd_, const options_t &options_,
-                                       const std::string &endpoint_) :
+zmq::stream_engine_t::stream_engine_t (fd_t fd_,
+        const options_t &options_,
+        const std::string &endpoint_,
+        bool has_handshake_stage_) :
     s (fd_),
     as_server(false),
     handle((handle_t)NULL),
@@ -78,6 +80,7 @@ zmq::stream_engine_t::stream_engine_t (fd_t fd_, const options_t &options_,
     greeting_size (v2_greeting_size),
     greeting_bytes_read (0),
     session (NULL),
+    _has_handshake_stage (has_handshake_stage_),
     options (options_),
     endpoint (endpoint_),
     plugged (false),
@@ -290,9 +293,12 @@ void zmq::stream_engine_t::in_event ()
     zmq_assert (!io_error);
 
     //  If still handshaking, receive and process the greeting message.
-    if (unlikely (handshaking))
+    if (unlikely (handshaking)) {
         if (!handshake ())
             return;
+        else if (mechanism == NULL && _has_handshake_stage)
+            session->engine_ready ();
+    }
 
     zmq_assert (decoder);
 
@@ -839,6 +845,9 @@ void zmq::stream_engine_t::mechanism_ready ()
         has_heartbeat_timer = true;
     }
 
+    if (_has_handshake_stage)
+        session->engine_ready ();
+
     if (options.recv_routing_id) {
         msg_t routing_id;
         mechanism->peer_routing_id (&routing_id);
diff --git a/src/stream_engine.hpp b/src/stream_engine.hpp
index fac8df6a..31b28454 100644
--- a/src/stream_engine.hpp
+++ b/src/stream_engine.hpp
@@ -68,11 +68,14 @@ namespace zmq
             timeout_error
         };
 
-        stream_engine_t (fd_t fd_, const options_t &options_,
-                         const std::string &endpoint);
+        stream_engine_t (fd_t fd_,
+                         const options_t &options_,
+                         const std::string &endpoint,
+                         bool has_handshake_stage);
         ~stream_engine_t ();
 
         //  i_engine interface implementation.
+        bool has_handshake_stage () { return _has_handshake_stage; };
         void plug (zmq::io_thread_t *io_thread_,
            zmq::session_base_t *session_);
         void terminate ();
@@ -176,6 +179,10 @@ namespace zmq
         //  The session this engine is attached to.
         zmq::session_base_t *session;
 
+        //  Indicate if engine has an handshake stage, if it does, engine must call session.engine_ready
+        //  when handshake is completed.
+        bool _has_handshake_stage;
+
         options_t options;
 
         // String representation of endpoint
diff --git a/src/tcp_connecter.cpp b/src/tcp_connecter.cpp
index 68878735..9366df4e 100644
--- a/src/tcp_connecter.cpp
+++ b/src/tcp_connecter.cpp
@@ -155,8 +155,8 @@ void zmq::tcp_connecter_t::out_event ()
     }
 
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow)
-        stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Attach the engine to the corresponding session object.
diff --git a/src/tcp_listener.cpp b/src/tcp_listener.cpp
index 7b929d42..7a5ac35f 100644
--- a/src/tcp_listener.cpp
+++ b/src/tcp_listener.cpp
@@ -107,8 +107,8 @@ void zmq::tcp_listener_t::in_event ()
     }
 
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow)
-        stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Choose I/O thread to run connecter in. Given that we are already
diff --git a/src/tipc_connecter.cpp b/src/tipc_connecter.cpp
index 92f35fec..6cdb0394 100644
--- a/src/tipc_connecter.cpp
+++ b/src/tipc_connecter.cpp
@@ -123,7 +123,8 @@ void zmq::tipc_connecter_t::out_event ()
         return;
     }
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Attach the engine to the corresponding session object.
diff --git a/src/tipc_listener.cpp b/src/tipc_listener.cpp
index 088346d7..7328346d 100644
--- a/src/tipc_listener.cpp
+++ b/src/tipc_listener.cpp
@@ -91,7 +91,8 @@ void zmq::tipc_listener_t::in_event ()
     }
 
     //  Create the engine object for this connection.
-    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
+    stream_engine_t *engine =
+        new (std::nothrow) stream_engine_t (fd, options, endpoint, !options.raw_socket);
     alloc_assert (engine);
 
     //  Choose I/O thread to run connecter in. Given that we are already
diff --git a/src/udp_engine.hpp b/src/udp_engine.hpp
index 233d05f6..c2cbc3ae 100644
--- a/src/udp_engine.hpp
+++ b/src/udp_engine.hpp
@@ -23,6 +23,8 @@ namespace zmq
 
             int init (address_t *address_, bool send_, bool recv_);
 
+            bool has_handshake_stage () { return false; };
+
             //  i_engine interface implementation.
             //  Plug the engine to the session.
             void plug (zmq::io_thread_t *io_thread_, class session_base_t *session_);
