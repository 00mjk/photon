From ea96f4c99a3e0991319cf6af197cf1689328e475 Mon Sep 17 00:00:00 2001
From: Ankit Jain <ankitja@vmware.com>
Date: Thu, 19 Mar 2020 11:51:38 +0530
Subject: [PATCH] stream: Fix for segfault on imfile read

- if cstrLen(pThis->prevMsgSegment) > maxMsgSize then len calculation
  become negative if cstrLen(thisLine) < cstrLen(pThis->prevMsgSegment)
  This causes illegal access to memory location and thus causing segfault.
- assigning len = 0 if cstrLen(pThis->prevMsgSegment) > maxMsgSize so that
  it access the correct memory location.

Signed-off-by: Ankit Jain <ankitja@vmware.com>
---
 runtime/stream.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/runtime/stream.c b/runtime/stream.c
index 8f6d08f2ac..79f37ca39e 100644
--- a/runtime/stream.c
+++ b/runtime/stream.c
@@ -1136,10 +1136,14 @@ strmReadMultiLine(strm_t *pThis, cstr_t **ppCStr, regex_t *start_preg, regex_t *
 							CHKiRet(cstrAppendCStr(pThis->prevMsgSegment, thisLine));
 							/* we could do this faster, but for now keep it simple */
 						} else {
-							len = currLineLen-(len-maxMsgSize);
-							for(int z=0; z<len; z++) {
-								cstrAppendChar(pThis->prevMsgSegment,
-								thisLine->pBuf[z]);
+							if (cstrLen(pThis->prevMsgSegment) > maxMsgSize) {
+								len = 0;
+							} else {
+								len = currLineLen-(len-maxMsgSize);
+								for(int z=0; z<len; z++) {
+									cstrAppendChar(pThis->prevMsgSegment,
+										thisLine->pBuf[z]);
+								}
 							}
 							finished = 1;
 							*ppCStr = pThis->prevMsgSegment;
