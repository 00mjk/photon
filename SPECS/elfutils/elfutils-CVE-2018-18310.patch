diff -ru a/ChangeLog b/ChangeLog
--- a/ChangeLog	2017-05-05 07:39:21.000000000 +0000
+++ b/ChangeLog	2019-04-18 19:56:52.623400870 +0000
@@ -1,3 +1,10 @@
+2018-10-14  Mark Wielaard  <mark@klomp.org>
+
+	* dwfl_segment_report_module.c (read_portion): Check requested
+	filesz isn't larger than buffer_available.
+	(dwfl_segment_report_module): Check data_size vs filesz after
+	read_portion call.
+
 2017-05-05  Mark Wielaard  <mark@klomp.org>
 
 	* configure.ac: Set version to 0.169. Update copyright year.
diff -ru a/libdwfl/dwfl_segment_report_module.c b/libdwfl/dwfl_segment_report_module.c
--- a/libdwfl/dwfl_segment_report_module.c	2016-12-25 13:36:55.000000000 +0000
+++ b/libdwfl/dwfl_segment_report_module.c	2019-04-18 20:04:56.271418167 +0000
@@ -1,5 +1,5 @@
 /* Sniff out modules from ELF headers visible in memory segments.
-   Copyright (C) 2008-2012, 2014, 2015 Red Hat, Inc.
+   Copyright (C) 2008-2012, 2014, 2015, 2018 Red Hat, Inc.   
    This file is part of elfutils.
 
    This file is free software; you can redistribute it and/or modify
@@ -301,7 +301,10 @@
   inline bool read_portion (void **data, size_t *data_size,
 			    GElf_Addr vaddr, size_t filesz)
   {
-    if (vaddr - start + filesz > buffer_available
+    /* Check whether we will have to read the segment data, or if it
+       can be returned from the existing buffer.  */
+    if (filesz > buffer_available
+	|| vaddr - start > buffer_available - filesz	  
 	/* If we're in string mode, then don't consider the buffer we have
 	   sufficient unless it contains the terminator of the string.  */
 	|| (filesz == 0 && memchr (vaddr - start + buffer, '\0',
@@ -452,6 +455,11 @@
     size_t data_size;
     if (read_portion (&data, &data_size, vaddr, filesz))
       return;
+    /* data_size will be zero if we got everything from the initial
+       buffer, otherwise it will be the size of the new buffer that
+       could be read.  */
+    if (data_size != 0)
+      filesz = data_size;
 
     assert (sizeof (Elf32_Nhdr) == sizeof (Elf64_Nhdr));
 
