diff -ru a/gettext-tools/gnulib-lib/libcroco/cr-parser.c b/gettext-tools/gnulib-lib/libcroco/cr-parser.c
--- a/gettext-tools/gnulib-lib/libcroco/cr-parser.c	2015-07-15 01:31:14.000000000 +0000
+++ b/gettext-tools/gnulib-lib/libcroco/cr-parser.c	2020-09-16 22:26:48.815557166 +0000
@@ -136,6 +136,8 @@
 #define PRIVATE(obj) ((obj)->priv)
 
 #define CHARS_TAB_SIZE 12
+#define RECURSIVE_CALLERS_LIMIT 100
+
 
 /**
  * IS_NUM:
@@ -345,9 +347,11 @@
 
 static enum CRStatus cr_parser_parse_declaration_core (CRParser * a_this);
 
-static enum CRStatus cr_parser_parse_any_core (CRParser * a_this);
+static enum CRStatus cr_parser_parse_any_core (CRParser * a_this,
+                                               guint      n_calls);
 
-static enum CRStatus cr_parser_parse_block_core (CRParser * a_this);
+static enum CRStatus cr_parser_parse_block_core (CRParser * a_this,
+                                                 guint      n_calls);
 
 static enum CRStatus cr_parser_parse_value_core (CRParser * a_this);
 
@@ -785,7 +789,7 @@
         cr_parser_try_to_skip_spaces_and_comments (a_this);
 
         do {
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, 0);		
         } while (status == CR_OK);
 
         status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
@@ -796,7 +800,7 @@
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, 
                                       token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_block_core (a_this, 0);		
                 CHECK_PARSING_STATUS (status,
                                       FALSE);
                 goto done;
@@ -931,11 +935,11 @@
 
         RECORD_INITIAL_POS (a_this, &init_pos);
 
-        status = cr_parser_parse_any_core (a_this);
+        status = cr_parser_parse_any_core (a_this, 0);	
         CHECK_PARSING_STATUS (status, FALSE);
 
         do {
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, 0);		
 
         } while (status == CR_OK);
 
@@ -957,16 +961,20 @@
  *in chapter 4.1 of the css2 spec.
  *block ::= '{' S* [ any | block | ATKEYWORD S* | ';' ]* '}' S*;
  *@param a_this the current instance of #CRParser.
+ *@param n_calls used to limit recursion depth 
  *FIXME: code this function.
  */
 static enum CRStatus
-cr_parser_parse_block_core (CRParser * a_this)
+cr_parser_parse_block_core (CRParser * a_this,
+                            guint      n_calls)
 {
         CRToken *token = NULL;
         CRInputPos init_pos;
         enum CRStatus status = CR_ERROR;
 
         g_return_val_if_fail (a_this && PRIVATE (a_this), CR_BAD_PARAM_ERROR);
+        if (n_calls > RECURSIVE_CALLERS_LIMIT)
+                return CR_ERROR;
 
         RECORD_INITIAL_POS (a_this, &init_pos);
 
@@ -997,13 +1005,13 @@
         } else if (token->type == CBO_TK) {
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_block_core (a_this, n_calls + 1);		
                 CHECK_PARSING_STATUS (status, FALSE);
                 goto parse_block_content;
         } else {
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, token);
                 token = NULL;
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, n_calls + 1);		
                 CHECK_PARSING_STATUS (status, FALSE);
                 goto parse_block_content;
         }
@@ -1110,7 +1118,7 @@
                 status = cr_tknzr_unget_token (PRIVATE (a_this)->tknzr,
                                                token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_block_core (a_this, 0);		
                 CHECK_PARSING_STATUS (status, FALSE);
                 ref++;
                 goto continue_parsing;
@@ -1124,7 +1132,7 @@
                 status = cr_tknzr_unget_token (PRIVATE (a_this)->tknzr,
                                                token);
                 token = NULL;
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, 0);		
                 if (status == CR_OK) {
                         ref++;
                         goto continue_parsing;
@@ -1163,10 +1171,12 @@
  *        | FUNCTION | DASHMATCH | '(' any* ')' | '[' any* ']' ] S*;
  *
  *@param a_this the current instance of #CRParser.
+ *@param n_calls used to limit recursion depth 
  *@return CR_OK upon successfull completion, an error code otherwise.
  */
 static enum CRStatus
-cr_parser_parse_any_core (CRParser * a_this)
+cr_parser_parse_any_core (CRParser * a_this,
+                          guint      n_calls)
 {
         CRToken *token1 = NULL,
                 *token2 = NULL;
@@ -1175,8 +1185,12 @@
 
         g_return_val_if_fail (a_this, CR_BAD_PARAM_ERROR);
 
+        if (n_calls > RECURSIVE_CALLERS_LIMIT)
+                return CR_ERROR;
+	
         RECORD_INITIAL_POS (a_this, &init_pos);
 
+
         status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr, &token1);
 
         ENSURE_PARSING_COND (status == CR_OK && token1);
@@ -1213,8 +1227,8 @@
                  *We consider parameter as being an "any*" production.
                  */
                 do {
-                        status = cr_parser_parse_any_core (a_this);
-                } while (status == CR_OK);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);                
+		} while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
                 status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
@@ -1238,7 +1252,7 @@
                 }
 
                 do {
-                        status = cr_parser_parse_any_core (a_this);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);			
                 } while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
@@ -1266,7 +1280,7 @@
                 }
 
                 do {
-                        status = cr_parser_parse_any_core (a_this);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);			
                 } while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
diff -ru a/gnulib-local/lib/libcroco/cr-parser.c b/gnulib-local/lib/libcroco/cr-parser.c
--- a/gnulib-local/lib/libcroco/cr-parser.c	2015-01-06 04:25:18.000000000 +0000
+++ b/gnulib-local/lib/libcroco/cr-parser.c	2020-09-16 18:35:52.160202053 +0000
@@ -137,6 +137,9 @@
 
 #define CHARS_TAB_SIZE 12
 
+#define RECURSIVE_CALLERS_LIMIT 100
+
+
 /**
  * IS_NUM:
  *@a_char: the char to test.
@@ -345,9 +348,11 @@
 
 static enum CRStatus cr_parser_parse_declaration_core (CRParser * a_this);
 
-static enum CRStatus cr_parser_parse_any_core (CRParser * a_this);
+static enum CRStatus cr_parser_parse_any_core (CRParser * a_this,
+                                               guint      n_calls);
 
-static enum CRStatus cr_parser_parse_block_core (CRParser * a_this);
+static enum CRStatus cr_parser_parse_block_core (CRParser * a_this,
+                                                 guint      n_calls);
 
 static enum CRStatus cr_parser_parse_value_core (CRParser * a_this);
 
@@ -785,7 +790,7 @@
         cr_parser_try_to_skip_spaces_and_comments (a_this);
 
         do {
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, 0);		
         } while (status == CR_OK);
 
         status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
@@ -796,7 +801,7 @@
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, 
                                       token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_block_core (a_this, 0);		
                 CHECK_PARSING_STATUS (status,
                                       FALSE);
                 goto done;
@@ -931,12 +936,11 @@
 
         RECORD_INITIAL_POS (a_this, &init_pos);
 
-        status = cr_parser_parse_any_core (a_this);
+        status = cr_parser_parse_any_core (a_this, 0);	
         CHECK_PARSING_STATUS (status, FALSE);
 
         do {
-                status = cr_parser_parse_any_core (a_this);
-
+                status = cr_parser_parse_any_core (a_this, 0);		
         } while (status == CR_OK);
 
         return CR_OK;
@@ -957,16 +961,20 @@
  *in chapter 4.1 of the css2 spec.
  *block ::= '{' S* [ any | block | ATKEYWORD S* | ';' ]* '}' S*;
  *@param a_this the current instance of #CRParser.
+ *@param n_calls used to limit recursion depth 
  *FIXME: code this function.
  */
 static enum CRStatus
-cr_parser_parse_block_core (CRParser * a_this)
+cr_parser_parse_block_core (CRParser * a_this,
+                            guint      n_calls)
 {
         CRToken *token = NULL;
         CRInputPos init_pos;
         enum CRStatus status = CR_ERROR;
 
         g_return_val_if_fail (a_this && PRIVATE (a_this), CR_BAD_PARAM_ERROR);
+        if (n_calls > RECURSIVE_CALLERS_LIMIT)
+                return CR_ERROR;
 
         RECORD_INITIAL_POS (a_this, &init_pos);
 
@@ -997,13 +1005,13 @@
         } else if (token->type == CBO_TK) {
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_any_core (a_this, n_calls + 1);
                 CHECK_PARSING_STATUS (status, FALSE);
                 goto parse_block_content;
         } else {
                 cr_tknzr_unget_token (PRIVATE (a_this)->tknzr, token);
                 token = NULL;
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, n_calls + 1);
                 CHECK_PARSING_STATUS (status, FALSE);
                 goto parse_block_content;
         }
@@ -1110,7 +1118,7 @@
                 status = cr_tknzr_unget_token (PRIVATE (a_this)->tknzr,
                                                token);
                 token = NULL;
-                status = cr_parser_parse_block_core (a_this);
+                status = cr_parser_parse_block_core (a_this, 0);		
                 CHECK_PARSING_STATUS (status, FALSE);
                 ref++;
                 goto continue_parsing;
@@ -1124,7 +1132,7 @@
                 status = cr_tknzr_unget_token (PRIVATE (a_this)->tknzr,
                                                token);
                 token = NULL;
-                status = cr_parser_parse_any_core (a_this);
+                status = cr_parser_parse_any_core (a_this, 0);		
                 if (status == CR_OK) {
                         ref++;
                         goto continue_parsing;
@@ -1163,10 +1171,12 @@
  *        | FUNCTION | DASHMATCH | '(' any* ')' | '[' any* ']' ] S*;
  *
  *@param a_this the current instance of #CRParser.
+ *@param n_calls used to limit recursion depth
  *@return CR_OK upon successfull completion, an error code otherwise.
  */
 static enum CRStatus
-cr_parser_parse_any_core (CRParser * a_this)
+cr_parser_parse_any_core (CRParser * a_this,
+                          guint      n_calls)
 {
         CRToken *token1 = NULL,
                 *token2 = NULL;
@@ -1174,6 +1184,8 @@
         enum CRStatus status = CR_ERROR;
 
         g_return_val_if_fail (a_this, CR_BAD_PARAM_ERROR);
+        if (n_calls > RECURSIVE_CALLERS_LIMIT)
+                return CR_ERROR;
 
         RECORD_INITIAL_POS (a_this, &init_pos);
 
@@ -1213,7 +1225,7 @@
                  *We consider parameter as being an "any*" production.
                  */
                 do {
-                        status = cr_parser_parse_any_core (a_this);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);			
                 } while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
@@ -1238,7 +1250,7 @@
                 }
 
                 do {
-                        status = cr_parser_parse_any_core (a_this);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);			
                 } while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
@@ -1266,7 +1278,7 @@
                 }
 
                 do {
-                        status = cr_parser_parse_any_core (a_this);
+                        status = cr_parser_parse_any_core (a_this, n_calls + 1);			
                 } while (status == CR_OK);
 
                 ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
