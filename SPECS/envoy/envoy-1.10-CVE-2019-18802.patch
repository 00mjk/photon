--- include/envoy/stream_info/stream_info.h_org	2020-01-20 15:12:09.458206769 +0530
+++ include/envoy/stream_info/stream_info.h	2020-01-21 11:41:50.296274500 +0530
@@ -7,6 +7,7 @@
 #include "envoy/api/v2/core/base.pb.h"
 #include "envoy/common/pure.h"
 #include "envoy/common/time.h"
+#include "envoy/http/header_map.h"
 #include "envoy/http/protocol.h"
 #include "envoy/ssl/connection.h"
 #include "envoy/stream_info/filter_state.h"
@@ -14,6 +15,7 @@
 
 #include "common/common/assert.h"
 #include "common/protobuf/protobuf.h"
+#include "common/singleton/const_singleton.h"
 
 #include "absl/types/optional.h"
 
@@ -60,10 +62,57 @@ enum ResponseFlag {
   UpstreamRetryLimitExceeded = 0x8000,
   // Request hit the stream idle timeout, triggering a 408.
   StreamIdleTimeout = 0x10000,
+  // Request specified x-envoy-* header values that failed strict header checks.
+  InvalidEnvoyRequestHeaders = 0x20000,
+  // Downstream request had an HTTP protocol error
+  DownstreamProtocolError = 0x40000,
   // ATTENTION: MAKE SURE THIS REMAINS EQUAL TO THE LAST FLAG.
-  LastFlag = StreamIdleTimeout
+  LastFlag = DownstreamProtocolError
 };
 
+
+/**
+ * Constants for the response code details field of StreamInfo for details
+ *  sentby core (non-extension) code.
+ *  These provide details about the stream state such as whether the
+ *  response is from the upstream or from envoy (in case of a localreply).
+ *  Custom extensions can define additional values provided they are appropriately
+ *  scoped to avoid collisions.
+ **/
+
+struct ResponseCodeDetailValues {
+    const std::string ViaUpstream = "via_upstream";
+    const std::string RequestPayloadTooLarge = "request_payload_too_large";
+    const std::string ResponsePayloadTooLArge = "response_payload_too_large";
+    const std::string StreamIdleTimeout = "stream_idle_timeout";
+    const std::string RequestOverallTimeout = "request_overall_timeout";
+    const std::string Overload = "overload";
+    const std::string LowVersion = "low_version";
+    const std::string MissingHost = "missing_host_header";
+    const std::string RequestHeadersTooLarge = "request_headers_too_large";
+    const std::string InvalidEnvoyRequestHeaders = "request_headers_failed_strict_check";
+    const std::string MissingPath = "missing_path_rejected";
+    const std::string AbsolutePath = "absolute_path_rejected";
+    const std::string PathNormalizationFailed = "path_normalization_failed";
+    const std::string UpgradeFailed = "upgrade_failed";
+    const std::string RouteConfigurationNotFound = "route_configuration_not_found";
+    const std::string RouteNotFound = "route_not_found";
+    const std::string DirectResponse = "direct_response";
+    const std::string ClusterNotFound = "cluster_not_found";
+    const std::string MaintenanceMode = "maintenance_mode";
+    const std::string NoHealthyUpstream = "no_healthy_upstream";
+    const std::string UpstreamTimeout = "upstream_response_timeout";
+    const std::string UpstreamPerTryTimeout = "upstream_per_try_timeout";
+    const std::string EarlyUpstreamReset = "upstream_reset_before_response_started";
+    const std::string LateUpstreamReset = "upstream_reset_after_response_started";
+    const std::string InvalidAuthority = "invalid_authority";
+};
+
+
+using ResponseCodeDetails = ConstSingleton<ResponseCodeDetailValues>;
+
+
+
 struct UpstreamTiming {
   /**
    * Sets the time when the first byte of the request was sent upstream.
--- source/common/http/conn_manager_impl.cc_org	2020-01-20 15:54:45.866205083 +0530
+++ source/common/http/conn_manager_impl.cc	2020-01-30 17:33:41.441293460 +0530
@@ -1,5 +1,4 @@
 #include "common/http/conn_manager_impl.h"
-
 #include <cstdint>
 #include <functional>
 #include <list>
@@ -31,7 +30,10 @@
 #include "common/http/http2/codec_impl.h"
 #include "common/http/path_utility.h"
 #include "common/http/utility.h"
+#include "common/http/header_utility.h"
 #include "common/network/utility.h"
+#include "common/runtime/runtime_impl.h"
+#include "common/router/config_impl.h"
 
 #include "absl/strings/escaping.h"
 #include "absl/strings/match.h"
@@ -648,6 +650,13 @@ void ConnectionManagerImpl::ActiveStream
       return;
     }
   }
+  // Make sure the host is valid.
+  if (Runtime::runtimeFeatureEnabled("envoy.reloadable_features.strict_authority_validation") &&
+                !HeaderUtility::authorityIsValid(request_headers_->Host()->value().getStringView())) {
+      sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, "",nullptr, 
+              is_head_request_, absl::nullopt);
+        return;
+    }
 
   ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);
   if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {
--- source/common/http/header_utility.cc_org	2020-01-20 17:59:04.424000875 +0530
+++ source/common/http/header_utility.cc	2020-01-30 19:35:46.814542788 +0530
@@ -6,6 +6,7 @@
 #include "common/protobuf/utility.h"
 
 #include "absl/strings/match.h"
+#include "nghttp2/nghttp2.h"
 
 namespace Envoy {
 namespace Http {
@@ -116,6 +117,14 @@ bool HeaderUtility::matchHeaders(const H
   return match != header_data.invert_match_;
 }
 
+bool HeaderUtility::authorityIsValid(const absl::string_view header_value) {
+      return (nghttp2_check_authority(reinterpret_cast<const uint8_t*>(header_value.data()),
+                                                    header_value.size()) != 0);
+}
+
+
+
+
 void HeaderUtility::addHeaders(Http::HeaderMap& headers, const Http::HeaderMap& headers_to_add) {
   headers_to_add.iterate(
       [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {
--- source/common/http/header_utility.h_org	2020-01-20 17:53:00.339991832 +0530
+++ source/common/http/header_utility.h	2020-01-20 17:57:51.739999070 +0530
@@ -51,6 +51,11 @@ public:
    * @param headers_to_add supplies the headers to be added
    */
   static void addHeaders(Http::HeaderMap& headers, const Http::HeaderMap& headers_to_add);
+  /**
+   *    Validates that the characters in the authority are valid.
+   *    @return bool true if the header values are valid, false otherwise.
+   **/
+  static bool authorityIsValid(const absl::string_view authority_value);
 };
 } // namespace Http
 } // namespace Envoy
--- source/common/http/http1/codec_impl.cc_org	2020-01-20 18:02:32.000006031 +0530
+++ source/common/http/http1/codec_impl.cc	2020-01-30 16:43:12.157264012 +0530
@@ -418,16 +418,19 @@ void ConnectionImpl::onHeaderValue(const
     // Ignore trailers.
     return;
   }
+   // Work around a bug in http_parser where trailing whitespace is not trimmed
+   // as the spec requires:https://tools.ietf.org/html/rfc7230#section-3.2.4
+  const absl::string_view header_value = StringUtil::trim(absl::string_view(data, length));
   // http-parser should filter for this
   // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings
   // have an invariant that they must not contain embedded zero characters
   // (NUL, ASCII 0x0).
-  if (absl::string_view(data, length).find('\0') != absl::string_view::npos) {
+  if (header_value.find('\0') != absl::string_view::npos) {
     throw CodecProtocolException("http/1.1 protocol error: header value contains NUL");
   }
 
   header_parsing_state_ = HeaderParsingState::Value;
-  current_header_value_.append(data, length);
+  current_header_value_.append(header_value.data(), header_value.length());
 
   const uint32_t total =
       current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();
--- source/common/runtime/runtime_features.cc_org	2020-01-20 18:22:45.652036175 +0530
+++ source/common/runtime/runtime_features.cc	2020-01-20 18:23:51.128037801 +0530
@@ -25,6 +25,8 @@ namespace Runtime {
 constexpr const char* runtime_features[] = {
     // Enabled
     "envoy.reloadable_features.test_feature_true",
+    "envoy.reloadable_features.strict_header_validation",
+    "envoy.reloadable_features.strict_authority_validation",
 };
 
 // This is a list of configuration fields which are disallowed by default in Envoy
--- include/envoy/stream_info/BUILD_org	2020-01-21 11:17:22.649658826 +0530
+++ include/envoy/stream_info/BUILD	2020-01-21 11:41:07.520274528 +0530
@@ -18,8 +18,10 @@ envoy_cc_library(
         "//include/envoy/http:protocol_interface",
         "//include/envoy/ssl:connection_interface",
         "//include/envoy/upstream:host_description_interface",
+        "//include/envoy/http:header_map_interface",
         "//source/common/common:assert_lib",
         "//source/common/protobuf",
+        "//source/common/singleton:const_singleton",
     ],
 )
 
--- source/common/stream_info/utility.cc_org	2020-01-21 11:50:14.621868433 +0530
+++ source/common/stream_info/utility.cc	2020-01-20 19:12:32.965378627 +0530
@@ -35,7 +35,7 @@ void ResponseFlagUtils::appendString(std
 const std::string ResponseFlagUtils::toShortString(const StreamInfo& stream_info) {
   std::string result;
 
-  static_assert(ResponseFlag::LastFlag == 0x10000, "A flag has been added. Fix this code.");
+  static_assert(ResponseFlag::LastFlag == 0x40000, "A flag has been added. Fix this code.");
 
   if (stream_info.hasResponseFlag(ResponseFlag::FailedLocalHealthCheck)) {
     appendString(result, FAILED_LOCAL_HEALTH_CHECK);
--- source/common/http/BUILD_org	2020-01-21 17:40:56.980977765 +0530
+++ source/common/http/BUILD	2020-01-30 17:35:52.973290020 +0530
@@ -135,11 +135,15 @@ envoy_cc_library(
         "conn_manager_impl.h",
         "conn_manager_utility.h",
     ],
+    external_deps = [
+                "nghttp2",
+        ],
     deps = [
         ":codes_lib",
         ":conn_manager_config_interface",
         ":exception_lib",
         ":header_map_lib",
+        ":header_utility_lib",
         ":headers_lib",
         ":path_utility_lib",
         ":user_agent_lib",
@@ -178,6 +182,8 @@ envoy_cc_library(
         "//source/common/runtime:uuid_util_lib",
         "//source/common/stream_info:stream_info_lib",
         "//source/common/tracing:http_tracer_lib",
+        "//source/common/router:config_lib",
+        "//source/common/config:utility_lib"
     ],
 )
 
@@ -305,12 +311,17 @@ envoy_cc_library(
     name = "header_utility_lib",
     srcs = ["header_utility.cc"],
     hdrs = ["header_utility.h"],
+    external_deps = [
+            "nghttp2",
+    ],
     deps = [
+        ":header_map_lib",
         "//include/envoy/http:header_map_interface",
         "//include/envoy/json:json_object_interface",
         "//source/common/common:utility_lib",
         "//source/common/config:rds_json_lib",
         "//source/common/protobuf:utility_lib",
+        "//source/common/runtime:runtime_lib",
         "@envoy_api//envoy/api/v2/route:route_cc",
         "@envoy_api//envoy/type:range_cc",
     ],
--- source/extensions/access_loggers/http_grpc/grpc_access_log_impl.cc_org	2020-01-21 18:58:17.210775516 +0530
+++ source/extensions/access_loggers/http_grpc/grpc_access_log_impl.cc	2020-01-21 18:58:39.994775500 +0530
@@ -87,7 +87,7 @@ void HttpGrpcAccessLog::responseFlagsToA
     envoy::data::accesslog::v2::AccessLogCommon& common_access_log,
     const StreamInfo::StreamInfo& stream_info) {
 
-  static_assert(StreamInfo::ResponseFlag::LastFlag == 0x10000,
+  static_assert(StreamInfo::ResponseFlag::LastFlag == 0x40000,
                 "A flag has been added. Fix this code.");
 
   if (stream_info.hasResponseFlag(StreamInfo::ResponseFlag::FailedLocalHealthCheck)) {
--- source/common/http/http1/codec_impl.h_org	2020-01-22 17:58:01.713580373 +0530
+++ source/common/http/http1/codec_impl.h	2020-01-30 17:07:02.433263069 +0530
@@ -175,6 +175,7 @@ protected:
   HeaderMapPtr deferred_end_stream_headers_;
   Http::Code error_code_{Http::Code::BadRequest};
   bool handling_upgrade_{};
+  bool strict_header_validation_ : 1;
 
 private:
   enum class HeaderParsingState { Field, Value, Done };
--- bazel/repository_locations.bzl_org	2020-01-30 18:17:10.934194108 +0530
+++ bazel/repository_locations.bzl	2020-01-30 18:19:19.178194024 +0530
@@ -97,9 +97,9 @@ REPOSITORY_LOCATIONS = dict(
         urls = ["https://github.com/nanopb/nanopb/archive/0.3.9.2.tar.gz"],
     ),
     com_github_nghttp2_nghttp2 = dict(
-        sha256 = "6b222a264aca23d497f7878a7751bd9da12676717493fe747db49afb51daae79",
-        strip_prefix = "nghttp2-1.36.0",
-        urls = ["https://github.com/nghttp2/nghttp2/releases/download/v1.36.0/nghttp2-1.36.0.tar.gz"],
+        sha256 = "eb9d9046495a49dd40c7ef5d6c9907b51e5a6b320ea6e2add11eb8b52c982c47",
+        strip_prefix = "nghttp2-1.40.0",
+        urls = ["https://github.com/nghttp2/nghttp2/releases/download/v1.40.0/nghttp2-1.40.0.tar.gz"],
     ),
     io_opentracing_cpp = dict(
         sha256 = "015c4187f7a6426a2b5196f0ccd982aa87f010cf61f507ae3ce5c90523f92301",
--- bazel/foreign_cc/nghttp2.patch_org	2019-04-05 23:37:44.000000000 +0530
+++ bazel/foreign_cc/nghttp2.patch	2020-01-30 19:00:56.647028293 +0530
@@ -1,5 +1,5 @@
 diff --git a/CMakeLists.txt b/CMakeLists.txt
-index e70d2d49..f9c5340e 100644
+index 35c77d1d..47bd63f5 100644
 --- a/CMakeLists.txt
 +++ b/CMakeLists.txt
 @@ -273,7 +273,11 @@ check_type_size("ssize_t" SIZEOF_SSIZE_T)
@@ -8,22 +8,10 @@ index e70d2d49..f9c5340e 100644
    # Set it to "int" to match the behavior of AC_TYPE_SSIZE_T (autotools).
 -  set(ssize_t int)
 +  if(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 8)
-+    set(ssize_t int64_t)
++    set(ssize_t ptrdiff_t)
 +  else()
 +    set(ssize_t int)
 +  endif()
  endif()
  # AC_TYPE_UINT8_T
  # AC_TYPE_UINT16_T
-diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
-index 17e422b2..a10f82a5 100644
---- a/lib/CMakeLists.txt
-+++ b/lib/CMakeLists.txt
-@@ -56,6 +56,7 @@ if(HAVE_CUNIT OR ENABLE_STATIC_LIB)
-     COMPILE_FLAGS "${WARNCFLAGS}"
-     VERSION ${LT_VERSION} SOVERSION ${LT_SOVERSION}
-     ARCHIVE_OUTPUT_NAME nghttp2
-+    ARCHIVE_OUTPUT_NAME nghttp2_static
-   )
-   target_compile_definitions(nghttp2_static PUBLIC "-DNGHTTP2_STATICLIB")
-   if(ENABLE_STATIC_LIB)
